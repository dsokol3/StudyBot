# Server Configuration
#server.port=8080
server.port=${PORT:8080}

# Async request timeout (60 seconds for LLM responses)
spring.mvc.async.request-timeout=60000

# Database Configuration
# Use individual env vars for flexibility, or override with DATABASE_URL/DB_URL for managed DBs
spring.datasource.url=${DATABASE_URL:${DB_URL:jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:chatbot}}}
spring.datasource.username=${DB_USERNAME:chatbot_user}
spring.datasource.password=${DB_PASSWORD:chatbot_password}
spring.datasource.driver-class-name=org.postgresql.Driver

# Connection pool settings for resilience
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.maximum-pool-size=5
spring.datasource.hikari.minimum-idle=1
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
spring.datasource.hikari.initialization-fail-timeout=-1

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=false
spring.jpa.defer-datasource-initialization=true
spring.jpa.open-in-view=false

# Enable Postgres extensions (pgvector)
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.sql.init.mode=always
spring.sql.init.platform=postgres
spring.sql.init.continue-on-error=true

# Spring Boot Actuator - Health Endpoints
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=always
management.endpoint.health.probes.enabled=true
management.health.db.enabled=true
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true

# LLM Configuration (Groq API - RECOMMENDED)
# Groq provides fast cloud inference for text generation
llm.api.url=${LLM_API_URL:https://api.groq.com/openai/v1}
llm.api.key=${LLM_API_KEY:}
llm.model=${LLM_MODEL:llama-3.1-8b-instant}

# Logging
logging.level.com.chatbot=INFO
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n

# Thread Pool Configuration
spring.task.execution.pool.core-size=5
spring.task.execution.pool.max-size=10
spring.task.execution.pool.queue-capacity=100

# RAG Configuration
rag.enabled=true
rag.upload.storage-path=./uploads
rag.upload.max-file-size=52428800
rag.chunking.size=450
rag.chunking.overlap=50
rag.retrieval.top-k=5
rag.retrieval.max-distance=0.5
rag.retrieval.similarity-threshold=0.5

# Google Gemini Embedding Configuration
# Use Google Gemini API for embeddings (text-embedding-004)
gemini.api.key=${GEMINI_API_KEY:}
gemini.api.max-retries=3
gemini.api.timeout-seconds=30
rag.embedding.dimension=768
rag.embedding.cache-enabled=true

# Column definition used for embedding storage. Defaults to Postgres pgvector type.
rag.vector.columnDefinition=vector(768)

# File upload limits
spring.servlet.multipart.max-file-size=50MB
spring.servlet.multipart.max-request-size=50MB

# UV Markdown Extractor Configuration
# Enable/disable UV markdown extraction (falls back to Tika if disabled or unavailable)
uv.enabled=true
# Path to markitdown command (default: markitdown, assumes it's in PATH or will use 'uv tool run')
uv.command.path=markitdown
# Timeout for markitdown command execution in seconds
uv.command.timeout=60
# Whether to use 'uv tool run' prefix (set to true if markitdown is not globally installed)
uv.use.tool.run=true
