# Server Configuration
#server.port=8080
server.port=${PORT:8080}

# Async request timeout (60 seconds for LLM responses)
spring.mvc.async.request-timeout=60000

# Database Configuration
# DATABASE_URL is converted in ChatBotApplication.main() to JDBC format
# Fallback to local development settings if no DATABASE_URL is set
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:chatbot}}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:${DB_USERNAME:chatbot_user}}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:${DB_PASSWORD:chatbot_password}}
spring.datasource.driver-class-name=org.postgresql.Driver

# Connection pool settings for resilience
spring.datasource.hikari.connection-timeout=20000
spring.datasource.hikari.maximum-pool-size=5
spring.datasource.hikari.minimum-idle=0
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=900000
spring.datasource.hikari.initialization-fail-timeout=0
spring.datasource.hikari.validation-timeout=5000

# JPA/Hibernate Configuration
# Use 'update' for auto schema management (creates tables on first run)
# Use 'validate' or 'none' in strict production environments
spring.jpa.hibernate.ddl-auto=${DDL_AUTO:update}
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.properties.hibernate.format_sql=false
spring.jpa.defer-datasource-initialization=true
spring.jpa.open-in-view=false
# Allow Hibernate to start without immediate DB connection
spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults=false
spring.jpa.properties.jakarta.persistence.schema-generation.database.action=none

# Disable Flyway (not using it - schema managed by Hibernate)
spring.flyway.enabled=false

# Enable Postgres extensions (pgvector)
spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true
spring.sql.init.mode=never
spring.sql.init.continue-on-error=true

# Spring Boot Actuator - Health Endpoints
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=when_authorized
management.endpoint.health.probes.enabled=true
management.health.db.enabled=false
management.health.livenessState.enabled=true
management.health.readinessState.enabled=true

# LLM Configuration (Groq API - RECOMMENDED)
# Groq provides fast cloud inference for text generation
llm.api.url=${LLM_API_URL:https://api.groq.com/openai/v1}
llm.api.key=${LLM_API_KEY:}
llm.model=${LLM_MODEL:llama-3.1-8b-instant}

# Logging
logging.level.com.chatbot=INFO
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n

# Thread Pool Configuration
spring.task.execution.pool.core-size=5
spring.task.execution.pool.max-size=10
spring.task.execution.pool.queue-capacity=100

# RAG Configuration
rag.enabled=true
rag.upload.storage-path=./uploads
rag.upload.max-file-size=52428800
rag.chunking.size=450
rag.chunking.overlap=50
rag.retrieval.top-k=5
rag.retrieval.max-distance=0.5
rag.retrieval.similarity-threshold=0.5

# Google Gemini Embedding Configuration
# Use Google Gemini API for embeddings (text-embedding-004)
gemini.api.key=${GEMINI_API_KEY:}
gemini.api.max-retries=3
gemini.api.timeout-seconds=30
rag.embedding.dimension=768
rag.embedding.cache-enabled=true

# Column definition used for embedding storage. Defaults to Postgres pgvector type.
rag.vector.columnDefinition=vector(768)

# File upload limits
spring.servlet.multipart.max-file-size=50MB
spring.servlet.multipart.max-request-size=50MB

# UV Markdown Extractor Configuration
# Enable/disable UV markdown extraction (falls back to Tika if disabled or unavailable)
uv.enabled=true
# Path to markitdown command (default: markitdown, assumes it's in PATH or will use 'uv tool run')
uv.command.path=markitdown
# Timeout for markitdown command execution in seconds
uv.command.timeout=60
# Whether to use 'uv tool run' prefix (set to true if markitdown is not globally installed)
uv.use.tool.run=true
